/*
 * Dalet Media Cortex API
 * # Scope Dalet Mediator API allows you to submit long running media jobs managed by Dalet services.  Long running media jobs include: - **Media processing** such as transcoding or automatic QC. - **Automatic metadata extraction** such as automatic speech transcription or face detection.  The Dalet Mediator API is a REST API with typed schema for the payload. # Architecture Job processing is performed on the cloud via dynamic combination of microservices. Dalet Mediator adopts the [EBU MCMA] architecture.  The key objectives of this architecture are to support: - Job management and monitoring - Long running transactions - Event based communication pattern - Service registration and discovery - Horizontal scalability in an elastic manner  The architecture is implemented using the serverless approach - relying on  independent microservices accessible through well documented REST endpoints and sharing a common object model. ## Roles The following services are involved in the processing of media jobs exposed through the Dalet Media Mediator API: - **Mediator**: this is the main entry point to the architecture; this API endpoint supports: 1. Checking authentication using an API key and a token mechanism 2. Verifying quota restrictions before accepting a submitted job 3. Keeping track of usage so that job processing can be tracked and billed 4. Keeping track of jobs metadata as a job repository - **Job Processor**: once a job request is accepted by the mediator, it is assigned to a Job Processor. The Job Processor dispatches the job to an appropriate Job Worker (depending on the job profile and other criteria such as load on the system and cost of operation).  It then keeps track of the progress of the job and its status until completion and possible failures and timeout.  It reports progress to the Mediator through notifications. - **Job Worker**: The Job Worker performs the actual work on the media object, for example, AI metadata extraction (AME) or essence transcoding.  It reports progress to the Job Processor through notifications. - **Service Registry**: The Service Registry keeps track of all active services in the architecture. It is queried by the Mediator and by Processors to discover candidate services to perform jobs.  It is updated whenever a new service is launched or stopped.  The Service Registry also stores the list of all job profiles supported by one of the Job Workers deployed in the architecture. The Dalet Mediator API abstracts away from the complexity of this orchestration and provides a simple endpoint to submit long running jobs and monitor the progress of their execution.  It serves as a facade for the additional technical services for authentication, usage monitoring and service registry.  [EBU MCMA]: /https://tech.ebu.ch/groups/mcma 'EBU MCMA' ## Job Lifecycle ![Job Lifecyle Diagram](./job_lifecycle.svg 'Job Lifecycle Diagram')  ## Authentication To use the Dalet Mediator API - you must obtain an APIKey from Dalet.  This key comes in the form of two parameters: * client ID * secret  Given these two parameters, a client program must first obtain an access token (GET /auth/access-token) and then associate this token to every subsequent calls.  When the token expires, the API will return a 401 error code.  In this case, the client must request a new token and resubmit the request. 
 *
 * The version of the OpenAPI document: 2.1.0
 * Contact: cortexsupport@dalet.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.dalet.mediator.cortex.model;

import java.util.Objects;
import com.dalet.mediator.cortex.model.JobOutput;
import com.dalet.mediator.cortex.model.Locator;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.dalet.mediator.cortex.JSON;

/**
 * Specifies where the captions computed by the Media Cortex service are to be stored.  Different formats can be requested (EBU-TT, SRT, JSON or text). &lt;ul&gt; &lt;li&gt;jsonFormat - Location of the output file into which metadata will be stored in JSON format.  The JSON format provides a timestamp for each transcribed. &lt;/li&gt; &lt;li&gt;ttmlFormat - Location of the output file into which the speech transcription will be stored as subtitles encode in EBU-TT (TTML) format.  See https://tech.ebu.ch/docs/tech/tech3350.pdf. &lt;/li&gt; &lt;li&gt;srtFormat - Location of the output file into which the speech transcription will be stored as subtitles encode in SRT format. See https://en.wikipedia.org/wiki/SubRip. &lt;/li&gt; &lt;li&gt;textFormat - Location of the output file into which the text of the speech transcription will be stored in simple format with no timestamps. &lt;/li&gt; &lt;li&gt;draftjsFormat - Location of the output file into which the text of the speech transcription will be stored in draftjs format. &lt;/li&gt; &lt;/ul&gt;
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-04-10T12:59:05.988996Z[Etc/UTC]", comments = "Generator version: 7.12.0")
public class SpeechToTextOutput extends JobOutput {
  public static final String SERIALIZED_NAME_JSON_FORMAT = "jsonFormat";
  @SerializedName(SERIALIZED_NAME_JSON_FORMAT)
  @javax.annotation.Nullable
  private Locator jsonFormat;

  public static final String SERIALIZED_NAME_TTML_FORMAT = "ttmlFormat";
  @SerializedName(SERIALIZED_NAME_TTML_FORMAT)
  @javax.annotation.Nullable
  private Locator ttmlFormat;

  public static final String SERIALIZED_NAME_SRT_FORMAT = "srtFormat";
  @SerializedName(SERIALIZED_NAME_SRT_FORMAT)
  @javax.annotation.Nullable
  private Locator srtFormat;

  public static final String SERIALIZED_NAME_TEXT_FORMAT = "textFormat";
  @SerializedName(SERIALIZED_NAME_TEXT_FORMAT)
  @javax.annotation.Nullable
  private Locator textFormat;

  public static final String SERIALIZED_NAME_DRAFTJS_FORMAT = "draftjsFormat";
  @SerializedName(SERIALIZED_NAME_DRAFTJS_FORMAT)
  @javax.annotation.Nullable
  private Locator draftjsFormat;

  public SpeechToTextOutput() {
    this.jobOutputType = this.getClass().getSimpleName();
  }

  public SpeechToTextOutput jsonFormat(@javax.annotation.Nullable Locator jsonFormat) {
    this.jsonFormat = jsonFormat;
    return this;
  }

  /**
   * Get jsonFormat
   * @return jsonFormat
   */
  @javax.annotation.Nullable
  public Locator getJsonFormat() {
    return jsonFormat;
  }

  public void setJsonFormat(@javax.annotation.Nullable Locator jsonFormat) {
    this.jsonFormat = jsonFormat;
  }


  public SpeechToTextOutput ttmlFormat(@javax.annotation.Nullable Locator ttmlFormat) {
    this.ttmlFormat = ttmlFormat;
    return this;
  }

  /**
   * Get ttmlFormat
   * @return ttmlFormat
   */
  @javax.annotation.Nullable
  public Locator getTtmlFormat() {
    return ttmlFormat;
  }

  public void setTtmlFormat(@javax.annotation.Nullable Locator ttmlFormat) {
    this.ttmlFormat = ttmlFormat;
  }


  public SpeechToTextOutput srtFormat(@javax.annotation.Nullable Locator srtFormat) {
    this.srtFormat = srtFormat;
    return this;
  }

  /**
   * Get srtFormat
   * @return srtFormat
   */
  @javax.annotation.Nullable
  public Locator getSrtFormat() {
    return srtFormat;
  }

  public void setSrtFormat(@javax.annotation.Nullable Locator srtFormat) {
    this.srtFormat = srtFormat;
  }


  public SpeechToTextOutput textFormat(@javax.annotation.Nullable Locator textFormat) {
    this.textFormat = textFormat;
    return this;
  }

  /**
   * Get textFormat
   * @return textFormat
   */
  @javax.annotation.Nullable
  public Locator getTextFormat() {
    return textFormat;
  }

  public void setTextFormat(@javax.annotation.Nullable Locator textFormat) {
    this.textFormat = textFormat;
  }


  public SpeechToTextOutput draftjsFormat(@javax.annotation.Nullable Locator draftjsFormat) {
    this.draftjsFormat = draftjsFormat;
    return this;
  }

  /**
   * Get draftjsFormat
   * @return draftjsFormat
   */
  @javax.annotation.Nullable
  public Locator getDraftjsFormat() {
    return draftjsFormat;
  }

  public void setDraftjsFormat(@javax.annotation.Nullable Locator draftjsFormat) {
    this.draftjsFormat = draftjsFormat;
  }

  /**
   * A container for additional, undeclared properties.
   * This is a holder for any undeclared properties as specified with
   * the 'additionalProperties' keyword in the OAS document.
   */
  private Map<String, Object> additionalProperties;

  /**
   * Set the additional (undeclared) property with the specified name and value.
   * If the property does not already exist, create it otherwise replace it.
   *
   * @param key name of the property
   * @param value value of the property
   * @return the SpeechToTextOutput instance itself
   */
  public SpeechToTextOutput putAdditionalProperty(String key, Object value) {
    if (this.additionalProperties == null) {
        this.additionalProperties = new HashMap<String, Object>();
    }
    this.additionalProperties.put(key, value);
    return this;
  }

  /**
   * Return the additional (undeclared) property.
   *
   * @return a map of objects
   */
  public Map<String, Object> getAdditionalProperties() {
    return additionalProperties;
  }

  /**
   * Return the additional (undeclared) property with the specified name.
   *
   * @param key name of the property
   * @return an object
   */
  public Object getAdditionalProperty(String key) {
    if (this.additionalProperties == null) {
        return null;
    }
    return this.additionalProperties.get(key);
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    SpeechToTextOutput speechToTextOutput = (SpeechToTextOutput) o;
    return Objects.equals(this.jsonFormat, speechToTextOutput.jsonFormat) &&
        Objects.equals(this.ttmlFormat, speechToTextOutput.ttmlFormat) &&
        Objects.equals(this.srtFormat, speechToTextOutput.srtFormat) &&
        Objects.equals(this.textFormat, speechToTextOutput.textFormat) &&
        Objects.equals(this.draftjsFormat, speechToTextOutput.draftjsFormat)&&
        Objects.equals(this.additionalProperties, speechToTextOutput.additionalProperties) &&
        super.equals(o);
  }

  @Override
  public int hashCode() {
    return Objects.hash(jsonFormat, ttmlFormat, srtFormat, textFormat, draftjsFormat, super.hashCode(), additionalProperties);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class SpeechToTextOutput {\n");
    sb.append("    ").append(toIndentedString(super.toString())).append("\n");
    sb.append("    jsonFormat: ").append(toIndentedString(jsonFormat)).append("\n");
    sb.append("    ttmlFormat: ").append(toIndentedString(ttmlFormat)).append("\n");
    sb.append("    srtFormat: ").append(toIndentedString(srtFormat)).append("\n");
    sb.append("    textFormat: ").append(toIndentedString(textFormat)).append("\n");
    sb.append("    draftjsFormat: ").append(toIndentedString(draftjsFormat)).append("\n");
    sb.append("    additionalProperties: ").append(toIndentedString(additionalProperties)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("jobOutputType");
    openapiFields.add("jsonFormat");
    openapiFields.add("ttmlFormat");
    openapiFields.add("srtFormat");
    openapiFields.add("textFormat");
    openapiFields.add("draftjsFormat");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("jobOutputType");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to SpeechToTextOutput
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!SpeechToTextOutput.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in SpeechToTextOutput is not found in the empty JSON string", SpeechToTextOutput.openapiRequiredFields.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : SpeechToTextOutput.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!SpeechToTextOutput.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'SpeechToTextOutput' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<SpeechToTextOutput> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(SpeechToTextOutput.class));

       return (TypeAdapter<T>) new TypeAdapter<SpeechToTextOutput>() {
           @Override
           public void write(JsonWriter out, SpeechToTextOutput value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             obj.remove("additionalProperties");
             // serialize additional properties
             if (value.getAdditionalProperties() != null) {
               for (Map.Entry<String, Object> entry : value.getAdditionalProperties().entrySet()) {
                 if (entry.getValue() instanceof String)
                   obj.addProperty(entry.getKey(), (String) entry.getValue());
                 else if (entry.getValue() instanceof Number)
                   obj.addProperty(entry.getKey(), (Number) entry.getValue());
                 else if (entry.getValue() instanceof Boolean)
                   obj.addProperty(entry.getKey(), (Boolean) entry.getValue());
                 else if (entry.getValue() instanceof Character)
                   obj.addProperty(entry.getKey(), (Character) entry.getValue());
                 else {
                   JsonElement jsonElement = gson.toJsonTree(entry.getValue());
                   if (jsonElement.isJsonArray()) {
                     obj.add(entry.getKey(), jsonElement.getAsJsonArray());
                   } else {
                     obj.add(entry.getKey(), jsonElement.getAsJsonObject());
                   }
                 }
               }
             }
             elementAdapter.write(out, obj);
           }

           @Override
           public SpeechToTextOutput read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             JsonObject jsonObj = jsonElement.getAsJsonObject();
             // store additional fields in the deserialized instance
             SpeechToTextOutput instance = thisAdapter.fromJsonTree(jsonObj);
             for (Map.Entry<String, JsonElement> entry : jsonObj.entrySet()) {
               if (!openapiFields.contains(entry.getKey())) {
                 if (entry.getValue().isJsonPrimitive()) { // primitive type
                   if (entry.getValue().getAsJsonPrimitive().isString())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsString());
                   else if (entry.getValue().getAsJsonPrimitive().isNumber())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsNumber());
                   else if (entry.getValue().getAsJsonPrimitive().isBoolean())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsBoolean());
                   else
                     throw new IllegalArgumentException(String.format("The field `%s` has unknown primitive type. Value: %s", entry.getKey(), entry.getValue().toString()));
                 } else if (entry.getValue().isJsonArray()) {
                     instance.putAdditionalProperty(entry.getKey(), gson.fromJson(entry.getValue(), List.class));
                 } else { // JSON object
                     instance.putAdditionalProperty(entry.getKey(), gson.fromJson(entry.getValue(), HashMap.class));
                 }
               }
             }
             return instance;
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of SpeechToTextOutput given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of SpeechToTextOutput
   * @throws IOException if the JSON string is invalid with respect to SpeechToTextOutput
   */
  public static SpeechToTextOutput fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, SpeechToTextOutput.class);
  }

  /**
   * Convert an instance of SpeechToTextOutput to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

